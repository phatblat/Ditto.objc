/*! \file */
/*******************************************
 *                                         *
 *  File auto-generated by `::safer_ffi`.  *
 *                                         *
 *  Do not manually edit this file.        *
 *                                         *
 *******************************************/

#ifndef __RUST_DITTOFFI__
#define __RUST_DITTOFFI__
#ifdef __cplusplus
extern "C" {
#endif
typedef struct CAuthServerAuthRequest CAuthServerAuthRequest_t;


#include <stddef.h>
#include <stdint.h>

void auth_server_auth_submit_with_error (
    CAuthServerAuthRequest_t * req,
    uint32_t _error_code);

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 * 
 *  # C layout (for some given type T)
 * 
 *  ```c
 *  typedef struct {
 *      // Cannot be NULL
 *      T * ptr;
 *      size_t len;
 *  } slice_T;
 *  ```
 * 
 *  # Nullable pointer?
 * 
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct {

    uint8_t const * ptr;

    size_t len;

} slice_ref_uint8_t;

void auth_server_auth_submit_with_success (
    CAuthServerAuthRequest_t * req,
    slice_ref_uint8_t success_cbor);

typedef struct CAuthServerRefreshRequest CAuthServerRefreshRequest_t;

void auth_server_refresh_submit_with_error (
    CAuthServerRefreshRequest_t * req,
    uint32_t _error_code);

void auth_server_refresh_submit_with_success (
    CAuthServerRefreshRequest_t * req,
    slice_ref_uint8_t success_cbor);

typedef struct TransportHandle_AwdlClientPlatformEvent TransportHandle_AwdlClientPlatformEvent_t;

/** \brief
 *  Generic enum used by crate and platforms to indicate a connection status
 */
typedef enum ConnectState {
    /** . */
    CONNECT_STATE_DISCONNECTED,
    /** . */
    CONNECT_STATE_CONNECTED,
    /** . */
    CONNECT_STATE_CONNECTING,
    /** . */
    CONNECT_STATE_DISCONNECTING,
} ConnectState_t;

/** \brief
 *  The platform advises Rust that a peer has changed its current connection
 *  status
 */
void awdl_client_connect_state_changed (
    TransportHandle_AwdlClientPlatformEvent_t const * handle,
    char const * announce,
    ConnectState_t state);

/** \brief
 *  The platform advises Rust that a complete message has been received from a
 *  remote peer
 */
void awdl_client_data_available (
    TransportHandle_AwdlClientPlatformEvent_t const * handle,
    char const * announce);

/** \brief
 *  The SDK requests to drop its handle to the AWDL Client Transport
 * 
 *  At some point dropping this events channel will effectively shut down and
 *  remove the Transport. At time of writing, the Transport is still owned
 *  within Peer.
 */
void awdl_client_free_handle (
    TransportHandle_AwdlClientPlatformEvent_t * handle);

/** \brief
 *  The platform advises Rust that a peer has been identified. We know only its
 *  announce string.
 */
void awdl_client_platform_peer_appeared (
    TransportHandle_AwdlClientPlatformEvent_t const * handle,
    char const * announce);

/** \brief
 *  The platform advises Rust that a peer has disappeared.
 */
void awdl_client_platform_peer_disappeared (
    TransportHandle_AwdlClientPlatformEvent_t const * handle,
    char const * announce);

/** \brief
 *  The platform advises Rust that a given peer is now clear to queue up a new
 *  message whenever one is ready to go
 */
void awdl_client_ready_to_send (
    TransportHandle_AwdlClientPlatformEvent_t const * handle,
    char const * announce);

/** \brief
 *  Generic enum used by crate and platforms to indicate online-ness.
 * 
 *  In other words, is something active or not? Not everything will use the
 *  transitional states.
 */
typedef enum OnlineState {
    /** . */
    ONLINE_STATE_OFFLINE,
    /** . */
    ONLINE_STATE_ONLINE,
    /** . */
    ONLINE_STATE_GOING_ONLINE,
    /** . */
    ONLINE_STATE_GOING_OFFLINE,
} OnlineState_t;

/** \brief
 *  A code reported by platforms/transports to indicate specific health
 *  conditions
 */
typedef enum TransportCondition {
    /** \brief
     *  A default state. Only use this for transient conditions, e.g., we are
     *  waiting for a platform to finish starting up. If everything is just
     *  quiet, use `Ok`.
     */
    TRANSPORT_CONDITION_UNKNOWN,
    /** \brief
     *  No known problems.
     */
    TRANSPORT_CONDITION_OK,
    /** \brief
     *  Catch-all failure, particularly for unexpected/internal faults. If
     *  possible, add a new case that the customer will be able to
     *  interpret.
     */
    TRANSPORT_CONDITION_GENERIC_FAILURE,
    /** \brief
     *  App is in background.
     */
    TRANSPORT_CONDITION_APP_IN_BACKGROUND,
    /** \brief
     *  We are not able to publish or discover with the mDNS daemon.
     */
    TRANSPORT_CONDITION_MDNS_FAILURE,
    /** \brief
     *  We cannot bind to a port.
     */
    TRANSPORT_CONDITION_TCP_LISTEN_FAILURE,
    /** \brief
     *  No app permission to act as a BLE Central.
     */
    TRANSPORT_CONDITION_NO_BLE_CENTRAL_PERMISSION,
    /** \brief
     *  No app permission to act as a BLE Peripheral.
     */
    TRANSPORT_CONDITION_NO_BLE_PERIPHERAL_PERMISSION,
    /** \brief
     *  This Transport targets a particular peer and we can't reach them right
     *  now.
     */
    TRANSPORT_CONDITION_CANNOT_ESTABLISH_CONNECTION,
    /** \brief
     *  The device has Bluetooth disabled at the OS level.
     */
    TRANSPORT_CONDITION_BLE_DISABLED,
    /** \brief
     *  The device has no Bluetooth hardware.
     */
    TRANSPORT_CONDITION_NO_BLE_HARDWARE,
    /** \brief
     *  The device has Wifi disabled at the OS level.
     */
    TRANSPORT_CONDITION_WIFI_DISABLED,
    /** \brief
     *  The platform has suspended briefly for internal reasons. Peers are
     *  reset.
     */
    TRANSPORT_CONDITION_TEMPORARILY_UNAVAILABLE,
} TransportCondition_t;

/** \brief
 *  The platform advises Rust that searching status changed
 */
void awdl_client_scanning_state_changed (
    TransportHandle_AwdlClientPlatformEvent_t const * handle,
    OnlineState_t state,
    TransportCondition_t condition);

typedef struct TransportHandle_AwdlServerPlatformEvent TransportHandle_AwdlServerPlatformEvent_t;

/** \brief
 *  The platform advises Rust that advertising status changed
 */
void awdl_server_advertising_state_changed (
    TransportHandle_AwdlServerPlatformEvent_t const * handle,
    OnlineState_t state,
    TransportCondition_t condition);

/** \brief
 *  The platform advises Rust that a peer has changed its current connection
 *  status
 */
void awdl_server_connect_state_changed (
    TransportHandle_AwdlServerPlatformEvent_t const * handle,
    int64_t platform_id,
    ConnectState_t state);

/** \brief
 *  The platform advises Rust that a complete message has been received from a
 *  remote peer
 */
void awdl_server_data_available (
    TransportHandle_AwdlServerPlatformEvent_t const * handle,
    int64_t platform_id);

/** \brief
 *  The SDK requests to drop its handle to the AWDL Server Transport
 * 
 *  At some point dropping this events channel will effectively shut down and
 *  remove the Transport. At time of writing, the Transport is still owned
 *  within Peer.
 */
void awdl_server_free_handle (
    TransportHandle_AwdlServerPlatformEvent_t * handle);

/** \brief
 *  The platform advises Rust that a peer has been identified. We know only its
 *  announce string.
 */
void awdl_server_platform_peer_appeared (
    TransportHandle_AwdlServerPlatformEvent_t const * handle,
    int64_t platform_id);

/** \brief
 *  The platform advises Rust that a peer has disappeared.
 */
void awdl_server_platform_peer_disappeared (
    TransportHandle_AwdlServerPlatformEvent_t const * handle,
    int64_t platform_id);

/** \brief
 *  The platform advises Rust that a given peer is now clear to queue up a new
 *  message whenever one is ready to go
 */
void awdl_server_ready_to_send (
    TransportHandle_AwdlServerPlatformEvent_t const * handle,
    int64_t platform_id);

typedef struct TransportHandle_BleClientPlatformEvent TransportHandle_BleClientPlatformEvent_t;

typedef struct {
    uint8_t idx[16];
} uint8_16_array_t;

void ble_advertisement_heard (
    TransportHandle_BleClientPlatformEvent_t const * handle,
    uint8_16_array_t const * peripheral_uuid,
    slice_ref_uint8_t local_name,
    float rssi);

typedef struct TransportHandle_BleServerPlatformEvent TransportHandle_BleServerPlatformEvent_t;

void ble_advertising_state_changed (
    TransportHandle_BleServerPlatformEvent_t const * handle,
    OnlineState_t state,
    TransportCondition_t result);

void ble_central_finished_connecting (
    TransportHandle_BleServerPlatformEvent_t const * handle,
    uint8_16_array_t const * uuid,
    slice_ref_uint8_t announce,
    int32_t l2cap_available,
    uint32_t mtu);

void ble_central_l2cap_data_available (
    TransportHandle_BleServerPlatformEvent_t const * handle,
    uint8_16_array_t const * uuid);

void ble_central_l2cap_ready_to_send (
    TransportHandle_BleServerPlatformEvent_t const * handle,
    uint8_16_array_t const * uuid);

void ble_central_mtu_updated (
    TransportHandle_BleServerPlatformEvent_t const * handle,
    uint8_16_array_t const * uuid,
    uint32_t mtu);

void ble_central_ready_to_send (
    TransportHandle_BleServerPlatformEvent_t const * handle,
    uint8_16_array_t const * uuid);

void ble_central_unsubscribed (
    TransportHandle_BleServerPlatformEvent_t const * handle,
    uint8_16_array_t const * central_uuid);

/** \brief
 *  The SDK requests to drop its handle to the BLE Client Transport
 * 
 *  At some point dropping this events channel will effectively shut down and
 *  remove the Transport. At time of writing, the Transport is still owned
 *  within Peer.
 */
void ble_client_free_handle (
    TransportHandle_BleClientPlatformEvent_t * handle);

void ble_connection_state_changed (
    TransportHandle_BleClientPlatformEvent_t const * handle,
    uint8_16_array_t const * peripheral_uuid,
    ConnectState_t state,
    int32_t l2cap_available,
    uint32_t mtu);

void ble_peripheral_l2cap_data_available (
    TransportHandle_BleClientPlatformEvent_t const * handle,
    uint8_16_array_t const * uuid);

void ble_peripheral_l2cap_ready_to_send (
    TransportHandle_BleClientPlatformEvent_t const * handle,
    uint8_16_array_t const * uuid);

void ble_peripheral_mtu_updated (
    TransportHandle_BleClientPlatformEvent_t const * handle,
    uint8_16_array_t const * uuid,
    uint32_t mtu);

void ble_peripheral_ready_to_send (
    TransportHandle_BleClientPlatformEvent_t const * handle,
    uint8_16_array_t const * uuid);

/** \brief
 *  When receiving data from a Bluetooth LE peer, such as a characteristic
 *  write, indicates what sort of data it is.
 */
typedef enum BleDataType {
    /** \brief
     *  The data _should_ contain the remote peer's announce string.
     *  Used during handshake.
     */
    BLE_DATA_TYPE_ANNOUNCE = 0,
    /** \brief
     *  Data message
     */
    BLE_DATA_TYPE_MESH_DATA = 1,
    /** \brief
     *  Control message
     */
    BLE_DATA_TYPE_CONTROL = 2,
} BleDataType_t;

void ble_received_from_central (
    TransportHandle_BleServerPlatformEvent_t const * handle,
    uint8_16_array_t const * central_uuid,
    BleDataType_t data_type,
    slice_ref_uint8_t data);

void ble_received_from_peripheral (
    TransportHandle_BleClientPlatformEvent_t const * handle,
    uint8_16_array_t const * peripheral_uuid,
    BleDataType_t data_type,
    slice_ref_uint8_t data);

void ble_scanning_state_changed (
    TransportHandle_BleClientPlatformEvent_t const * handle,
    OnlineState_t state,
    TransportCondition_t result);

/** \brief
 *  The SDK requests to drop its handle to the BLE Server Transport
 * 
 *  At some point dropping this events channel will effectively shut down and
 *  remove the Transport. At time of writing, the Transport is still owned
 *  within Peer.
 */
void ble_server_free_handle (
    TransportHandle_BleServerPlatformEvent_t * handle);

typedef struct CDitto CDitto_t;

/** \brief
 *  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.
 * 
 *  # C layout (for some given type T)
 * 
 *  ```c
 *  typedef struct {
 *      // Cannot be NULL
 *      T * ptr;
 *      size_t len;
 *  } slice_T;
 *  ```
 * 
 *  # Nullable pointer?
 * 
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct {

    uint8_t * ptr;

    size_t len;

} slice_mut_uint8_t;

typedef struct {

    void (*start_searching)(void *, char const *, char const *);

    void (*stop_searching)(void *);

    void (*request_connect)(void *, char const *);

    void (*request_disconnect)(void *, char const *);

    int32_t (*send_data)(void *, char const *, slice_ref_uint8_t);

    int32_t (*read_data)(void *, char const *, slice_mut_uint8_t);

} AwdlClientCallbacks_t;

TransportHandle_AwdlClientPlatformEvent_t * ditto_add_awdl_client_transport (
    CDitto_t * ditto,
    AwdlClientCallbacks_t callbacks,
    void * ctx,
    void (*retain)(void *),
    void (*release)(void *));

typedef struct {

    void (*start_advertising)(void *, char const *, char const *);

    void (*stop_advertising)(void *);

    void (*request_disconnect)(void *, int64_t);

    int32_t (*send_data)(void *, int64_t, slice_ref_uint8_t);

    int32_t (*read_data)(void *, int64_t, slice_mut_uint8_t);

} AwdlServerCallbacks_t;

TransportHandle_AwdlServerPlatformEvent_t * ditto_add_awdl_server_transport (
    CDitto_t * ditto,
    AwdlServerCallbacks_t callbacks,
    void * ctx,
    void (*retain)(void *),
    void (*release)(void *));


#include <stdbool.h>

/** \brief
 *  Rust-level representation of the result of a send operation, converted from
 *  a bitfield
 */
typedef struct {

    bool accepted;

    bool wait_for_ready;

} SendResult_t;

typedef struct {

    void (*start_scanning)(void *, uint8_16_array_t const *, slice_ref_uint8_t);

    void (*stop_scanning)(void *);

    OnlineState_t (*scanning_state)(void *);

    void (*connect_peripheral)(void *, uint8_16_array_t const *);

    void (*disconnect_peripheral)(void *, uint8_16_array_t const *);

    SendResult_t (*write_to_peripheral)(void *, BleDataType_t, uint8_16_array_t const *, slice_ref_uint8_t);

    bool (*app_is_in_foreground)(void *);

    int32_t (*read_l2cap_from_peripheral)(void *, uint8_16_array_t const *, slice_mut_uint8_t);

    int32_t (*send_l2cap_to_peripheral)(void *, uint8_16_array_t const *, slice_ref_uint8_t);

} BleClientCallbacks_t;

TransportHandle_BleClientPlatformEvent_t * ditto_add_ble_client_transport (
    CDitto_t * ditto,
    BleClientCallbacks_t callbacks,
    void * ctx,
    void (*retain)(void *),
    void (*release)(void *));

typedef struct {

    void (*start_advertising)(void *, uint8_16_array_t const *, slice_ref_uint8_t);

    void (*stop_advertising)(void *);

    OnlineState_t (*advertising_state)(void *);

    SendResult_t (*notify_to_central)(void *, BleDataType_t, uint8_16_array_t const *, slice_ref_uint8_t);

    bool (*app_is_in_foreground)(void *);

    int32_t (*read_l2cap_from_central)(void *, uint8_16_array_t const *, slice_mut_uint8_t);

    int32_t (*send_l2cap_to_central)(void *, uint8_16_array_t const *, slice_ref_uint8_t);

} BleServerCallbacks_t;

TransportHandle_BleServerPlatformEvent_t * ditto_add_ble_server_transport (
    CDitto_t * ditto,
    BleServerCallbacks_t callbacks,
    void * ctx,
    void (*retain)(void *),
    void (*release)(void *));

TransportHandle_BleClientPlatformEvent_t * ditto_add_internal_ble_client_transport (
    CDitto_t * ditto);

TransportHandle_BleServerPlatformEvent_t * ditto_add_internal_ble_server_transport (
    CDitto_t * ditto);

typedef struct {

    void (*start_advertising)(void *, char const *, char const *, uint16_t);

    void (*stop_advertising)(void *);

} MdnsServerCallbacks_t;

typedef struct TransportHandle_MdnsServerPlatformEvent TransportHandle_MdnsServerPlatformEvent_t;

TransportHandle_MdnsServerPlatformEvent_t * ditto_add_mdns_advertiser (
    CDitto_t * ditto,
    MdnsServerCallbacks_t callbacks,
    void * ctx,
    void (*retain)(void *),
    void (*release)(void *));

typedef struct {

    void (*start_searching)(void *, char const *);

    void (*stop_searching)(void *);

    void (*resolve_service)(void *, slice_ref_uint8_t);

} MdnsClientCallbacks_t;

typedef struct TransportHandle_MdnsClientPlatformEvent TransportHandle_MdnsClientPlatformEvent_t;

TransportHandle_MdnsClientPlatformEvent_t * ditto_add_mdns_transport (
    CDitto_t * ditto,
    MdnsClientCallbacks_t callbacks,
    void * ctx,
    void (*retain)(void *),
    void (*release)(void *));

void ditto_add_multicast_transport (
    CDitto_t * ditto);

typedef struct TransportHandle_StaticTcpClientPlatformEvent TransportHandle_StaticTcpClientPlatformEvent_t;

TransportHandle_StaticTcpClientPlatformEvent_t * ditto_add_static_tcp_client (
    CDitto_t const * ditto,
    char const * address);

int32_t ditto_add_subscription (
    CDitto_t const * ditto,
    char const * collection,
    char const * query,
    slice_ref_uint8_t query_args_cbor);

typedef struct TransportHandle_WebsocketClientPlatformEvent TransportHandle_WebsocketClientPlatformEvent_t;

TransportHandle_WebsocketClientPlatformEvent_t * ditto_add_websocket_client (
    CDitto_t const * ditto,
    char const * address);

typedef struct CAuthClient CAuthClient_t;

void ditto_auth_client_free (
    CAuthClient_t * auth_client);

uint64_t ditto_auth_client_get_site_id (
    CAuthClient_t const * auth_client);

int32_t ditto_auth_client_is_web_valid (
    CAuthClient_t const * auth_client);

int32_t ditto_auth_client_is_x509_valid (
    CAuthClient_t const * auth_client);

int32_t ditto_auth_client_login_with_credentials (
    CAuthClient_t const * auth_client,
    char const * username,
    char const * password,
    char const * provider);

int32_t ditto_auth_client_login_with_token (
    CAuthClient_t const * auth_client,
    char const * token,
    char const * provider);

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct {

    uint8_t * ptr;

    size_t len;

    size_t cap;

} Vec_uint8_t;

typedef struct {

    int32_t return_code;

    Vec_uint8_t client_info;

} AuthenticationResult_t;

AuthenticationResult_t ditto_auth_client_login_with_token_and_feedback (
    CAuthClient_t const * auth_client,
    char const * token,
    char const * provider);

int32_t ditto_auth_client_logout (
    CAuthClient_t const * auth_client);

typedef struct {

    int32_t status_code;

    CAuthClient_t * auth_client;

} AuthClientResult_t;

AuthClientResult_t ditto_auth_client_make_for_development (
    char const * working_dir,
    char const * app_id,
    uint64_t site_id);

typedef struct CLoginProvider CLoginProvider_t;

/** \brief
 *  Create a LoginProvider. Ownership passes to the SDK.
 * 
 *  This cannot be freed directly - it should be passed in when creating an
 *  AuthClient.
 */
CLoginProvider_t * ditto_auth_client_make_login_provider (
    void * ctx,
    void (*retain)(void *),
    void (*release)(void *),
    void (*expiring_cb)(void *, uint32_t));

AuthClientResult_t ditto_auth_client_make_with_shared_key (
    char const * working_dir,
    char const * app_id,
    char const * key_der_b64,
    uint64_t site_id);

AuthClientResult_t ditto_auth_client_make_with_static_x509 (
    char const * config_cbor_b64);

AuthClientResult_t ditto_auth_client_make_with_web (
    char const * working_dir,
    char const * app_id,
    char const * base_url,
    CLoginProvider_t * login_provider);

/** \brief
 *  Create a LoginProvider. Ownership passes to the SDK.
 * 
 *  This cannot be freed directly - it should be passed in when creating an
 *  AuthClient.
 */
void ditto_auth_client_set_validity_listener (
    CAuthClient_t const * auth_client,
    void * ctx,
    void (*retain)(void *),
    void (*release)(void *),
    void (*validity_update_cb)(void *, int32_t, int32_t));

char * ditto_auth_client_user_id (
    CAuthClient_t const * auth_client);

void ditto_auth_login_provider_free (
    CLoginProvider_t * login_provider);

/** \brief
 *  [`Box`][`rust::Box`]`<[T]>` (fat pointer to a slice),
 *  but with a guaranteed `#[repr(C)]` layout.
 * 
 *  # C layout (for some given type T)
 * 
 *  ```c
 *  typedef struct {
 *      // Cannot be NULL
 *      T * ptr;
 *      size_t len;
 *  } slice_T;
 *  ```
 * 
 *  # Nullable pointer?
 * 
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct {

    uint8_t * ptr;

    size_t len;

} slice_boxed_uint8_t;

/** \brief
 *  Releases a byte array value returned by DittoStore.
 * 
 *  DittoStore manages its own memory allocations and it is not safe to release
 *  such values with C's `free()`. That's why the structures it returns provide
 *  their own associated `free` function.
 * 
 *  It should be used for values returned by functions like
 *  `ditto_document_cbor`.
 */
void ditto_c_bytes_free (
    slice_boxed_uint8_t bytes);

/** \brief
 *  Releases `char *` value returned by DittoStore.
 * 
 *  DittoStore manages its own memory allocations and it is not safe to release
 *  such values with C's `free()`. That's why the structures it returns provide
 *  their own associated `free` function and this is one we need for `char *`.
 * 
 *  It should be used for values returned by functions like
 *  `ditto_document_id_query_compatible`.
 */
void ditto_c_string_free (
    char * s);

/** \brief
 *  Empty error callback
 *  (useful for passing to `err_cb` functions to ignore errors; use with
 *  caution)
 */
void ditto_callback_err_nop (
    int32_t _code,
    char const * _err,
    void * _data);

/** \brief
 *  Empty callback (useful for passing to `free` functions)
 */
void ditto_callback_nop (
    void const * _data);

/** \brief
 *  Cancels a resolve callback registered by ditto_resolve_attachment.
 * 
 *  Returns following error codes:
 * 
 *  * `0` -- no error
 *  * `1` -- an error
 *  * `2` -- invalid id
 *  * `3` -- token not found
 * 
 *  In case of a non-zero return value, error message can be retrieved using
 *  `ditto_error_message` function.
 */
uint32_t ditto_cancel_resolve_attachment (
    CDitto_t const * ditto,
    slice_ref_uint8_t id,
    uint64_t cancel_token);

/** \brief
 *  Deregister any presence callback, releasing the receiver on the SDK side.
 */
void ditto_clear_presence_callback (
    CDitto_t * ditto);

int32_t ditto_collection (
    CDitto_t const * ditto,
    char const * name);

typedef struct CWriteTransaction CWriteTransaction_t;

typedef struct {

    int32_t status_code;

    bool bool_value;

} BoolResult_t;

/** \brief
 *  Evict a document from the collection, using the provided write transaction.
 * 
 *  `was_evicted` is set to indicate whether the document was removed
 *  successfully.
 */
BoolResult_t ditto_collection_evict (
    CDitto_t const * ditto,
    char const * coll_name,
    CWriteTransaction_t * transaction,
    slice_ref_uint8_t id);

typedef enum QuerySortDirection {
    /** . */
    QUERY_SORT_DIRECTION_ASCENDING = 1,
    /** . */
    QUERY_SORT_DIRECTION_DESCENDING,
} QuerySortDirection_t;

/** \brief
 *  OrderBy Parameter
 */
typedef struct {

    char const * query_c_str;

    QuerySortDirection_t direction;

} COrderByParam_t;

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 * 
 *  # C layout (for some given type T)
 * 
 *  ```c
 *  typedef struct {
 *      // Cannot be NULL
 *      T * ptr;
 *      size_t len;
 *  } slice_T;
 *  ```
 * 
 *  # Nullable pointer?
 * 
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct {

    COrderByParam_t const * ptr;

    size_t len;

} slice_ref_COrderByParam_t;

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct {

    slice_boxed_uint8_t * ptr;

    size_t len;

    size_t cap;

} Vec_slice_boxed_uint8_t;

typedef struct {

    int32_t status_code;

    Vec_slice_boxed_uint8_t ids;

} DocIdsResult_t;

/** \brief
 *  Evict all documents returned by the specified query from a collection.
 * 
 *  `out_ids` is set to the list of IDs of all documents successfully evicted.
 */
DocIdsResult_t ditto_collection_evict_query_str (
    CDitto_t const * ditto,
    char const * coll_name,
    CWriteTransaction_t * transaction,
    char const * query,
    slice_ref_uint8_t query_args_cbor,
    slice_ref_COrderByParam_t order_by_params,
    int32_t limit,
    uint32_t offset);

typedef struct CDocument CDocument_t;

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct {

    CDocument_t * * ptr;

    size_t len;

    size_t cap;

} Vec_CDocument_ptr_t;

typedef struct {

    int32_t status_code;

    Vec_CDocument_ptr_t documents;

} DocumentsResult_t;

/** \brief
 *  Execute the specified query on a collection.
 * 
 *  `out_documents` is set to the list of all documents successfully retrieved
 *  from the collection.
 */
DocumentsResult_t ditto_collection_exec_query_str (
    CDitto_t const * ditto,
    char const * coll_name,
    CWriteTransaction_t * transaction,
    char const * query,
    slice_ref_uint8_t query_args_cbor,
    slice_ref_COrderByParam_t order_by_params,
    int32_t limit,
    uint32_t offset);

typedef struct CReadTransaction CReadTransaction_t;

typedef struct {

    int32_t status_code;

    CDocument_t * document;

} DocumentResult_t;

DocumentResult_t ditto_collection_get (
    CDitto_t const * ditto,
    char const * coll_name,
    slice_ref_uint8_t id,
    CReadTransaction_t * transaction);

typedef enum WriteStrategyRs {
    /** \brief
     *  Create or merge with existing data
     */
    WRITE_STRATEGY_RS_MERGE,
    /** \brief
     *  Create or overwrite existing
     */
    WRITE_STRATEGY_RS_OVERWRITE,
    /** \brief
     *  Only insert if no document already exists with the same document ID
     */
    WRITE_STRATEGY_RS_INSERT_IF_ABSENT,
    /** \brief
     *  Insert as default data, only if no document already exists with the same
     *  document ID
     */
    WRITE_STRATEGY_RS_INSERT_DEFAULT_IF_ABSENT,
} WriteStrategyRs_t;

typedef struct {

    int32_t status_code;

    slice_boxed_uint8_t id;

} DocIdResult_t;

/** \brief
 *  Inserts a document into the store.
 * 
 *  If an ID is provided explicitly via the `doc_id` parameter then that will be
 *  used as the document's ID. If an ID is provided implicitly via the
 *  document's value (`doc_cbor`) then that will be used as the document's ID,
 *  assuming no explicit ID was provided. If neither an explicit nor an implicit
 *  document ID was provided then a new document ID will be generated and used
 *  as the new document's ID.
 * 
 *  Return codes:
 * 
 *  * `0` -- success
 *  * `1` -- improper CBOR provided for the document value
 *  * `2` -- invalid CBOR for the document value (i.e. the CBOR could be parsed
 *    but it represented a non-`Object` value)
 *  * `3` -- unable to create document ID from value at `_id` key in document's
 *    value (`doc_cbor` argument)
 */
DocIdResult_t ditto_collection_insert_value (
    CDitto_t const * ditto,
    char const * coll_name,
    slice_ref_uint8_t doc_cbor,
    slice_ref_uint8_t doc_id,
    WriteStrategyRs_t write_strategy,
    CWriteTransaction_t * txn);

/** \brief
 *  Remove a document from the collection, using the provided write transaction.
 * 
 *  `out_removed` is set to indicate whether the document was removed
 *  successfully.
 */
BoolResult_t ditto_collection_remove (
    CDitto_t const * ditto,
    char const * coll_name,
    CWriteTransaction_t * transaction,
    slice_ref_uint8_t id);

/** \brief
 *  Remove all documents returned by the specified query from a collection.
 * 
 *  `out_ids` is set to the list of IDs of all documents successfully removed.
 */
DocIdsResult_t ditto_collection_remove_query_str (
    CDitto_t const * ditto,
    char const * coll_name,
    CWriteTransaction_t * transaction,
    char const * query,
    slice_ref_uint8_t query_args_cbor,
    slice_ref_COrderByParam_t order_by_params,
    int32_t limit,
    uint32_t offset);

int32_t ditto_collection_update (
    CDitto_t const * ditto,
    char const * coll_name,
    CWriteTransaction_t * transaction,
    CDocument_t * document);

/** \brief
 *  Update multiple documents in a collection, using the provided write
 *  transaction.
 * 
 *  # Return Values
 * 
 *  - Returns `0` if all links were successfully updated in all documents.
 *  - Returns `-1` if one or more documents' links fail to all update
 *  successfully, but all documents themselves are successfully updated. Note
 *  that in the event of an attachment failing to update, updates are still
 *  attempted on the rest of the attachments and the rest of the documents.
 *  - If a document fails to update, the appropriate error code is returned for
 *  the cause of the failure. Note that if a document fails to update, no more
 *  document updates are attempted.
 */
int32_t ditto_collection_update_multiple (
    CDitto_t const * ditto,
    char const * coll_name,
    CWriteTransaction_t * transaction,
    Vec_CDocument_ptr_t documents);

/** \brief
 *  Document's CBOR
 */
slice_boxed_uint8_t ditto_document_cbor (
    CDocument_t const * document);

/** \brief
 *  Releases the document
 */
void ditto_document_free (
    CDocument_t * document);

/** \brief
 *  Gets the CBOR value at the pointer.
 * 
 *  The `.ptr` field is `NULL` if none found (in which case the length contains
 *  garbage).
 * 
 *  The resulting bytes have to be released with `::ditto_c_bytes_free`
 */
slice_boxed_uint8_t ditto_document_get_cbor (
    CDocument_t const * document,
    char const * pointer);

/** \brief
 *  Document's ID
 * 
 *  The resulting bytes have to be freed with `::ditto_c_bytes_free`
 */
slice_boxed_uint8_t ditto_document_id (
    CDocument_t const * document);

/** \brief
 *  Defines how string primitives should be encoded. This is relevant if a
 *  document ID was created from a string. There are occasions when we want the
 *  stringified representation of the document ID do include quotes around the
 *  string, for example when creating a query like `_id == "abc"`. However,
 *  there are also times when we want to return the string as just a string, for
 *  example when we're injecting a document ID into a document's value before
 *  then serializing the document and sending those bytes across the FFI
 *  boundary.
 */
typedef enum StringPrimitiveFormat {
    /** . */
    STRING_PRIMITIVE_FORMAT_WITH_QUOTES,
    /** . */
    STRING_PRIMITIVE_FORMAT_WITHOUT_QUOTES,
} StringPrimitiveFormat_t;

/** \brief
 *  Convert a document ID from CBOR bytes into a Ditto query language compatible
 *  string.
 * 
 *  The resulting string has to be freed with `::ditto_c_string_free`
 */
char * ditto_document_id_query_compatible (
    slice_ref_uint8_t id,
    StringPrimitiveFormat_t string_primitive_format);

int32_t ditto_document_increment_counter (
    CDocument_t * document,
    char const * pointer,
    double amount);

/** \brief
 *  Inserts a value into a document. The behavior depends on the `Repr` of the
 *  element at the JMESPath path pointed to by `pointer`.
 * 
 *  ```text
 *  // ________________________________________________________________________________________
 *  // |`pointer`   | Foo `Repr` | Action                                                     |
 *  // |------------|------------|------------------------------------------------------------|
 *  // | "foo.bar"  | Object     | Sets the bar property to the supplied CBOR item            |
 *  // | "foo[1]"   | Array      | Inserts the supplied CBOR item at the index specified      |
 *  // ----------------------------------------------------------------------------------------
 *  ```
 * 
 *  # Arguments
 * 
 *  * `document` - A pointer to the document which was previously returned from
 *    a query.
 *  * `pointer` - A JMESPath _pointer_ to a `Repr` within `document` which is to
 *    be removed.
 * 
 *  # Returns
 * 
 *  `0` if the remove was successful or non-zero to indicate failure. To
 *  retrieve an error message in the case of failure, call
 *  `ditto_error_message()`.
 */
int32_t ditto_document_insert_cbor (
    CDocument_t * document,
    char const * pointer,
    slice_ref_uint8_t cbor);

int32_t ditto_document_pop_cbor (
    CDocument_t * document,
    char const * pointer,
    slice_boxed_uint8_t * out_cbor);

int32_t ditto_document_push_cbor (
    CDocument_t * document,
    char const * pointer,
    slice_ref_uint8_t cbor);

/** \brief
 *  Removes a value from a document. The behavior depends on the `Repr` of the
 *  element at the JMESPath path pointed to by `pointer`.
 * 
 *  ```text
 *  // ________________________________________________________________________________________
 *  // |`pointer`   | Foo `Repr` | Action                                                     |
 *  // |------------|------------|------------------------------------------------------------|
 *  // | "foo.bar"  | Object     | Deletes bar property                                       |
 *  // | "foo[1]"   | Array      | Removes at index and shifts all subsequent indexes right   |
 *  // ----------------------------------------------------------------------------------------
 *  ```
 * 
 *  # Arguments
 * 
 *  * `document` - A pointer to the document which was previously returned from
 *    a query.
 *  * `pointer` - A JMESPath _pointer_ to a `Repr` within `document` which is to
 *    be removed.
 * 
 *  # Returns
 * 
 *  `0` if the remove was successful or non-zero to indicate failure. To
 *  retrieve an error message in the case of failure, call
 *  `ditto_error_message()`.
 */
int32_t ditto_document_remove (
    CDocument_t * document,
    char const * pointer);

int32_t ditto_document_replace_with_counter (
    CDocument_t * document,
    char const * pointer);

int32_t ditto_document_replace_with_counter_with_timestamp (
    CDocument_t * document,
    char const * pointer,
    uint32_t timestamp);

int32_t ditto_document_set_cbor (
    CDocument_t * document,
    char const * pointer,
    slice_ref_uint8_t cbor,
    bool create_path);

int32_t ditto_document_set_cbor_with_timestamp (
    CDocument_t * document,
    char const * pointer,
    slice_ref_uint8_t cbor,
    bool create_path,
    uint32_t timestamp);

/** \brief
 *  Updates the document with values taken from provided CBOR data.
 * 
 *  Returns following error codes:
 * 
 *  * `0` -- no error
 *  * `1` -- invalid CBOR data
 *  * `2` -- CBOR data was not a map
 *  * `3` -- update error
 *  * `4` -- `_id` key provided
 * 
 *  In case of a non-zero return value, error message can be retrieved using
 *  `::ditto_error_message` function.
 */
int32_t ditto_document_update (
    CDocument_t * document,
    slice_ref_uint8_t cbor,
    bool create_path);

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 * 
 *  # C layout (for some given type T)
 * 
 *  ```c
 *  typedef struct {
 *      // Cannot be NULL
 *      T * ptr;
 *      size_t len;
 *  } slice_T;
 *  ```
 * 
 *  # Nullable pointer?
 * 
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct {

    CDocument_t * const * ptr;

    size_t len;

} slice_ref_CDocument_ptr_t;

typedef struct {

    int32_t status_code;

    uint64_t u64;

} U64Result_t;

U64Result_t ditto_documents_hash (
    slice_ref_CDocument_ptr_t documents);

typedef struct {

    int32_t status_code;

    char * c_string;

} BoxedCharPtrResult_t;

BoxedCharPtrResult_t ditto_documents_hash_mnemonic (
    slice_ref_CDocument_ptr_t documents);

/** \brief
 *  Calls ditto_shutdown and also:
 *  - Stops the live queries
 *  - Clears presence callback
 */
void ditto_drop (
    CDitto_t * ditto);

/** \brief
 *  Retrieves last thread-local error message (used by some synchronous APIs)
 *  and removes it. Subsequent call to this function (if nothing else has
 *  happened) will always return `NULL`.
 * 
 *  Returns `NULL` if there was no error. A non-null result MUST be freed using
 *  `ditto_c_string_free`.
 */
char * ditto_error_message (void);

/** \brief
 *  Retrieves last thread-local error message (used by some synchronous APIs)
 *  and retains ownership of it.
 * 
 *  Returns `NULL` if there was no error. A non-null result MUST be freed using
 *  `ditto_c_string_free`.
 */
char * ditto_error_message_peek (void);

/** \brief
 *  Stop replication and all internal threads in the Ditto object.
 *  The ditto object is freed by this function and must not be used again.
 *   - Calls everything in ditto_drop
 *   - Calls everything in ditto_shutdown
 */
void ditto_free (
    CDitto_t * ditto);

typedef struct AttachmentHandle AttachmentHandle_t;

void ditto_free_attachment_handle (
    AttachmentHandle_t * handle);

/** \brief
 *  Frees a `Vec_CDocument_ptr_t`, used in `c_cb_params`.
 * 
 *  \remark This functions frees both the backing buffer allocation and each
 *  individual `Document` pointer. If ownership has been taken of the latter,
 *  then you must ensure the `len` field of the struct is zeroed before calling
 *  this function.
 */
void ditto_free_documents (
    Vec_CDocument_ptr_t documents);

/** \brief
 *  [`Box`][`rust::Box`]`<[T]>` (fat pointer to a slice),
 *  but with a guaranteed `#[repr(C)]` layout.
 * 
 *  # C layout (for some given type T)
 * 
 *  ```c
 *  typedef struct {
 *      // Cannot be NULL
 *      T * ptr;
 *      size_t len;
 *  } slice_T;
 *  ```
 * 
 *  # Nullable pointer?
 * 
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct {

    size_t * ptr;

    size_t len;

} slice_boxed_size_t;

/** \brief
 *  Frees a `slice_box_size_t`, used in `c_cb_params`.
 */
void ditto_free_indices (
    slice_boxed_size_t indices);

typedef struct {

    int32_t status_code;

    AttachmentHandle_t * handle;

} AttachmentHandleResult_t;

AttachmentHandleResult_t ditto_get_attachment_status (
    CDitto_t * ditto,
    slice_ref_uint8_t id);

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct {

    char * * ptr;

    size_t len;

    size_t cap;

} Vec_char_ptr_t;

typedef struct {

    int32_t status_code;

    Vec_char_ptr_t names;

} CollectionNamesResult_t;

CollectionNamesResult_t ditto_get_collection_names (
    CDitto_t const * ditto);

typedef struct {

    int8_t status;

    slice_boxed_uint8_t data;

} AttachmentDataResult_t;

AttachmentDataResult_t ditto_get_complete_attachment_data (
    CDitto_t const * ditto,
    AttachmentHandle_t const * handle);

char * ditto_get_complete_attachment_path (
    CDitto_t const * ditto,
    AttachmentHandle_t const * handle);

/** \brief
 *  Returns a human-readable SDK version string.
 * 
 *  The returned string must be freed.
 */
char * ditto_get_sdk_version (void);

typedef enum Platform {
    /** . */
    PLATFORM_WINDOWS,
    /** . */
    PLATFORM_MAC,
    /** . */
    PLATFORM_IOS,
    /** . */
    PLATFORM_ANDROID,
    /** . */
    PLATFORM_LINUX,
    /** . */
    PLATFORM_WEB,
    /** . */
    PLATFORM_UNKNOWN,
} Platform_t;

typedef enum Language {
    /** . */
    LANGUAGE_SWIFT,
    /** . */
    LANGUAGE_OBJECTIVE_C,
    /** . */
    LANGUAGE_C_PLUS_PLUS,
    /** . */
    LANGUAGE_C_SHARP,
    /** . */
    LANGUAGE_JAVA_SCRIPT,
    /** . */
    LANGUAGE_UNKNOWN,
    /** . */
    LANGUAGE_RUST,
} Language_t;

void ditto_init_sdk_version (
    Platform_t platform,
    Language_t language,
    char const * sdk_semver);

typedef struct {
    uint8_t idx[8];
} uint8_8_array_t;

/** \brief
 *  Construct a new Timeseries Event from the following parts:
 *    * `timestamp` - u64 Unix epoch seconds as 8 big endian bytes
 *    * `nanos` - Number of nanoseconds offset into the current second
 *    * `ts_name` - The name of the timeseries
 *    * `cbor` - The cbor content for the event
 *    * `txn` - An optional write transaction. If one is provided then it will
 *      not be committed. If one is not provided then one will be obtained and
 *      it will be committed.
 * 
 *  Return codes:
 *    * `0` -- success
 *    * `1` -- invalid CBOR
 *    * `2` -- `cbor` is not an object
 */
int32_t ditto_insert_timeseries_event (
    CDitto_t const * ditto,
    uint8_8_array_t timestamp,
    uint32_t nanos,
    char const * ts_name,
    slice_ref_uint8_t cbor,
    CWriteTransaction_t * txn);

void ditto_invalidate_tcp_listeners (
    CDitto_t const * ditto);

/** \brief
 *  Describes how a live query callback's availability should be treated.
 * 
 *  If `Always` is specified then as soon as a transaction is committed that
 *  impacts the live query the consumer-provided callback will be called with
 *  the relevant update information. This can be temporarily delayed if there's
 *  a lot of activity leading to the event receivers lagging or if groups of
 *  transactions are coalesced into a single live query update.
 * 
 *  If `WhenSignalled` is specified then the consumer-provided live query
 *  callback will only be called when there is a transaction committed that
 *  impacts the live query *and* the consumer has signalled that they are ready
 *  to receive a new live query event (via the callback).
 */
typedef enum LiveQueryAvailability {
    /** . */
    LIVE_QUERY_AVAILABILITY_ALWAYS,
    /** . */
    LIVE_QUERY_AVAILABILITY_WHEN_SIGNALLED,
} LiveQueryAvailability_t;

typedef struct {

    Vec_CDocument_ptr_t documents;

    bool is_initial;

    Vec_CDocument_ptr_t old_documents;

    slice_boxed_size_t insertions;

    slice_boxed_size_t deletions;

    slice_boxed_size_t updates;

    slice_boxed_size_t moves;

} c_cb_params_t;

typedef struct {

    int32_t status_code;

    int64_t i64;

} I64Result_t;

/** \brief
 *  Convenience function for `ditto_live_query_register`, so as not to require
 *  pre-compiling the query.
 */
I64Result_t ditto_live_query_register_str (
    CDitto_t const * ditto,
    char const * coll_name,
    char const * query,
    slice_ref_uint8_t query_args_cbor,
    slice_ref_COrderByParam_t order_by,
    int32_t limit,
    uint32_t offset,
    LiveQueryAvailability_t lq_availability,
    void * ctx,
    void (*retain)(void *),
    void (*release)(void *),
    void (*c_cb)(void *, c_cb_params_t));

void ditto_live_query_signal_available_next (
    CDitto_t const * ditto,
    int64_t id);

int32_t ditto_live_query_start (
    CDitto_t const * ditto,
    int64_t id);

void ditto_live_query_stop (
    CDitto_t const * ditto,
    int64_t id);

int32_t ditto_live_query_webhook_generate_new_api_secret (
    CDitto_t const * ditto);

DocIdResult_t ditto_live_query_webhook_register_str (
    CDitto_t const * ditto,
    char const * coll_name,
    char const * query,
    slice_ref_COrderByParam_t order_by,
    int32_t limit,
    uint32_t offset,
    char const * url);

int32_t ditto_live_query_webhook_start_all (
    CDitto_t const * ditto);

int32_t ditto_live_query_webhook_start_by_id (
    CDitto_t const * ditto,
    slice_ref_uint8_t id);

typedef enum CLogLevel {
    /** . */
    C_LOG_LEVEL_ERROR = 1,
    /** . */
    C_LOG_LEVEL_WARNING,
    /** . */
    C_LOG_LEVEL_INFO,
    /** . */
    C_LOG_LEVEL_DEBUG,
    /** . */
    C_LOG_LEVEL_VERBOSE,
} CLogLevel_t;

/** \brief
 *  Log function called over FFI such that logging can be grouped into a single
 *  logging mechanism.
 */
void ditto_log (
    CLogLevel_t level,
    char const * msg);

void ditto_logger_emoji_headings_enabled (
    bool enabled);

bool ditto_logger_emoji_headings_enabled_get (void);

void ditto_logger_enabled (
    bool enabled);

bool ditto_logger_enabled_get (void);

/** \brief
 *  Initializes and registers the global Ditto logger.
 */
void ditto_logger_init (void);

void ditto_logger_minimum_log_level (
    CLogLevel_t log_level);

CLogLevel_t ditto_logger_minimum_log_level_get (void);

/** \brief
 *  Registers a custom logging callback to be called whenever Ditto wants to
 *  issue a log (on _top_ of emitting the log to the console).
 * 
 *  Care should be taken not to perform any Ditto operations within this
 *  callback, since those could emit new ditto logs, leading to a recursive
 *  situation. More specifically, this should not be fed `ditto_log`.
 * 
 *  A `NULL` may be fed to provide no callback (thus unregistering any
 *  previously registered one).
 */
void ditto_logger_set_custom_log_cb (
    void (*custom_log_cb)(CLogLevel_t, char const *));

/** \brief
 *  Registers a file path where logs will be written to, whenever Ditto wants
 *  to issue a log (on _top_ of emitting the log to the console).
 * 
 *  The path, if any, must be within an already existing directory.
 * 
 *  A `NULL` may be fed to provide no file (thus unregistering any previously
 *  registered one).
 * 
 *  Returns `0` on success, and `-1` otherwise (and the thread local error
 *  message is set accordingly).
 */
int8_t ditto_logger_set_log_file (
    char const * log_file);

typedef struct UninitializedDitto UninitializedDitto_t;

/** \brief
 *  Make a Ditto object as an opaque pointer. The Ditto object creates the Tokio
 *  runtime and starts internal threads. The return value is a raw pointer whose
 *  only use is to supply as an argument to other ditto_* functions. The Ditto
 *  object must be stopped and freed with ditto_free().
 */
CDitto_t * ditto_make (
    UninitializedDitto_t * uninit_ditto,
    CAuthClient_t const * auth_client);

typedef struct {

    slice_boxed_uint8_t id;

    uint64_t len;

    AttachmentHandle_t * handle;

} Attachment_t;

/** \brief
 *  Creates new Attachment from a blob of bytes link it to the given Document.
 * 
 *  Returns following error codes:
 * 
 *  * `0` -- no error
 *  * `1` -- an error
 * 
 *  In case of a non-zero return value, error message can be retrieved using
 *  `ditto_error_message` function.
 */
uint32_t ditto_new_attachment_from_bytes (
    CDitto_t const * ditto,
    slice_ref_uint8_t bytes,
    Attachment_t * out_attachment);

/** \brief
 *  Describes how an attachment file should be handled by our Rust code.
 * 
 *  In most cases copying the file will be desirable but with the Android SDK,
 *  for example, we sometimes want to create a tempfile from an InputStream
 *  associated with the attachment file and then move that tempfile rather than
 *  copy it, so as to not make unnecessary copies.
 */
typedef enum AttachmentFileOperation {
    /** . */
    ATTACHMENT_FILE_OPERATION_COPY = 1,
    /** . */
    ATTACHMENT_FILE_OPERATION_MOVE,
} AttachmentFileOperation_t;

/** \brief
 *  Creates new Attachment from a file and link it to the given Document.
 * 
 *  Returns following error codes:
 * 
 *  * `0` -- no error
 *  * `1` -- an error
 *  * `2` -- file not found
 *  * `3` -- permission denied
 * 
 *  In case of a non-zero return value, error message can be retrieved using
 *  `ditto_error_message` function.
 */
uint32_t ditto_new_attachment_from_file (
    CDitto_t const * ditto,
    char const * source_path,
    AttachmentFileOperation_t file_operation,
    Attachment_t * out_attachment);

/** \brief
 *  Request data showing who we are connected to in a user-friendly way.
 */
char * ditto_presence_v1 (
    CDitto_t * ditto);

/** \brief
 *  Request data showing who we are connected to in a user-friendly way.
 */
char * ditto_presence_v2 (
    CDitto_t * ditto);

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 * 
 *  # C layout (for some given type T)
 * 
 *  ```c
 *  typedef struct {
 *      // Cannot be NULL
 *      T * ptr;
 *      size_t len;
 *  } slice_T;
 *  ```
 * 
 *  # Nullable pointer?
 * 
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct {

    char const * const * ptr;

    size_t len;

} slice_ref_char_const_ptr_t;

U64Result_t ditto_queries_hash (
    CDitto_t const * ditto,
    slice_ref_char_const_ptr_t coll_names,
    slice_ref_char_const_ptr_t queries);

BoxedCharPtrResult_t ditto_queries_hash_mnemonic (
    CDitto_t const * ditto,
    slice_ref_char_const_ptr_t coll_names,
    slice_ref_char_const_ptr_t queries);

typedef struct {

    int32_t status_code;

    CReadTransaction_t * txn;

} CReadTransactionResult_t;

CReadTransactionResult_t ditto_read_transaction (
    CDitto_t const * ditto);

void ditto_read_transaction_free (
    CReadTransaction_t * transaction);

void ditto_register_bus_callback (
    CDitto_t const * ditto,
    void * ctx,
    void (*retain)(void *),
    void (*release)(void *),
    void (*c_cb)(void *, uint64_t, slice_ref_uint8_t));

/** \brief
 *  Register a server that can authenticate client requests for an identity.
 * 
 *  Its route will be included in the HTTP server transport, if configured.
 */
int32_t ditto_register_local_auth_server (
    CDitto_t * ditto,
    char const * signing_key_pem,
    slice_ref_char_const_ptr_t verifying_keys_pem,
    char const * ca_key_pem,
    void * ctx,
    void (*retain)(void *),
    void (*release)(void *),
    void (*auth_cb)(void *, CAuthServerAuthRequest_t *, slice_ref_uint8_t),
    void (*refresh_cb)(void *, CAuthServerRefreshRequest_t *, slice_ref_uint8_t));

/** \brief
 *  Register a function that will be called every time the connection state
 *  of remote peers changes.
 */
void ditto_register_presence_v1_callback (
    CDitto_t * ditto,
    void * ctx,
    void (*retain)(void *),
    void (*release)(void *),
    void (*c_cb)(void *, char const *));

/** \brief
 *  Register a function that will be called every time the connection state
 *  of remote peers changes.
 */
void ditto_register_presence_v2_callback (
    CDitto_t * ditto,
    void * ctx,
    void (*retain)(void *),
    void (*release)(void *),
    void (*c_cb)(void *, char const *));

/** \brief
 *  User-friendly categories describing where condition events arose
 */
typedef enum ConditionSource {
    /** . */
    CONDITION_SOURCE_BLUETOOTH,
    /** . */
    CONDITION_SOURCE_TCP,
    /** . */
    CONDITION_SOURCE_AWDL,
    /** . */
    CONDITION_SOURCE_MDNS,
} ConditionSource_t;

/** \brief
 *  Register a function that will be called every time a transport changes
 *  condition.
 * 
 *  This should drive UI indicators to indicate overall connectivity via methods
 *  such as BLE, WiFi, or an internet-based server on a dedicated
 *  WsConnectTransport.
 */
void ditto_register_transport_condition_changed_callback (
    CDitto_t * ditto,
    void * ctx,
    void (*retain)(void *),
    void (*release)(void *),
    void (*c_cb)(void *, ConditionSource_t, TransportCondition_t));

void ditto_remove_mdns_advertiser (
    CDitto_t const * ditto);

void ditto_remove_multicast_transport (
    CDitto_t * ditto);

int32_t ditto_remove_subscription (
    CDitto_t const * ditto,
    char const * collection,
    char const * query,
    slice_ref_uint8_t query_args_cbor);

typedef struct {

    int32_t status_code;

    int64_t cancel_token;

} CancelTokenResult_t;

/** \brief
 *  Register a new callback to resolve the attachment.
 * 
 *  The callback status could be:
 *  * `0` -- complete, with a handle that can be used in
 *    ditto_get_complete_attachment_path
 *  * `1` -- progress, with additional info about bytes downloaded and total
 *    bytes to download
 *  * `2` -- deleted, as the attachment ceased to exist in the doc database
 * 
 *  Returns following error codes:
 * 
 *  * `0` -- no error
 *  * `1` -- an error
 *  * `2` -- invalid id
 *  * `3` -- attachment not found
 * 
 *  In case of a non-zero return value, error message can be retrieved using
 *  `ditto_error_message` function.
 */
CancelTokenResult_t ditto_resolve_attachment (
    CDitto_t const * ditto,
    slice_ref_uint8_t id,
    void * ctx,
    void (*retain)(void *),
    void (*release)(void *),
    void (*on_complete_cb)(void *, AttachmentHandle_t *),
    void (*on_progress_cb)(void *, uint64_t, uint64_t),
    void (*on_deleted_cb)(void *));

uint32_t ditto_run_garbage_collection (
    CDitto_t * ditto);

uint32_t ditto_send_bus_message (
    CDitto_t const * ditto,
    uint64_t destination,
    slice_ref_uint8_t message);

void ditto_set_device_name (
    CDitto_t * ditto,
    char const * device_name);

void ditto_set_max_outgoing_ble_peers (
    uint32_t count);

void ditto_set_sync_group (
    CDitto_t * ditto,
    uint32_t sync_group);

/** \brief
 *  Shutdown as much of the Ditto Peer
 *  as possible via interior mutability
 *  - shuts down all advertisers
 *  - stops all servers
 *  - stops all TCP listeners
 *  - Outbound replication should stop when the peer is dropped
 */
void ditto_shutdown (
    CDitto_t const * ditto);

/** \brief
 *  Whether or not to offer a WebSocket sync server on the HTTP server.
 */
typedef enum WebSocketMode {
    /** . */
    WEB_SOCKET_MODE_ENABLED,
    /** . */
    WEB_SOCKET_MODE_DISABLED,
} WebSocketMode_t;

/** \brief
 *  Start the WebSocket server
 * 
 *  * `bind` - optional bind string of the form "ip:port"
 *  * `static_path` - optional absolute path to content on disk that should be
 *    served from `/`
 *  * `enable_websocket` - whether to enable a WebSocket server at the reserved
 *    path `/_ditto/ws`
 *  * `tls_cert_path` - path to this server's TLS certificate file, or null if
 *    not using TLS
 *  * `tls_key_path` - path to this server's TLS private key file, or null if
 *    not using TLS
 */
int32_t ditto_start_http_server (
    CDitto_t const * ditto,
    char const * bind,
    char const * static_path,
    WebSocketMode_t enable_websocket,
    char const * tls_cert_path,
    char const * tls_key_path);

/** \brief
 *  Start the WebSocket server
 */
int32_t ditto_start_tcp_server (
    CDitto_t const * ditto,
    char const * bind);

void ditto_stop_all_live_queries (
    CDitto_t * ditto);

int32_t ditto_stop_http_server (
    CDitto_t const * ditto);

int32_t ditto_stop_tcp_server (
    CDitto_t const * ditto);

/** \brief
 *  Listen address of `tcp_listen_transport`.
 * 
 *  Must be called after `transport_go_online()`.
 *  The return value must be freed with `ditto_c_string_free()`.
 */
char * ditto_tcp_server_listen_addr (
    CDitto_t * ditto);

/** \brief
 *  Request bulk status information about the transports. Intended mostly for
 *  statistical or debugging purposes.
 */
char * ditto_transports_diagnostics (
    CDitto_t * ditto);

void ditto_unregister_local_auth_server (
    CDitto_t * ditto);

uint32_t ditto_validate_document_id (
    slice_ref_uint8_t cbor,
    slice_boxed_uint8_t * out_cbor);

void ditto_vec_char_ptr_free (
    Vec_char_ptr_t char_p);

void ditto_vec_documents_free (
    Vec_CDocument_ptr_t docs);

void ditto_vec_slice_boxed_uint8_t_free (
    Vec_slice_boxed_uint8_t slice_boxed);

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct {

    size_t * ptr;

    size_t len;

    size_t cap;

} Vec_size_t;

void ditto_vec_usizes_free (
    Vec_size_t usizes);

typedef struct {

    int32_t status_code;

    CWriteTransaction_t * txn;

} CWriteTransactionResult_t;

CWriteTransactionResult_t ditto_write_transaction (
    CDitto_t const * ditto);

int32_t ditto_write_transaction_commit (
    CDitto_t const * ditto,
    CWriteTransaction_t * transaction);

void ditto_write_transaction_free (
    CWriteTransaction_t * transaction);

void ditto_write_transaction_rollback (
    CWriteTransaction_t * transaction);

void free_c_string_vec (
    Vec_char_ptr_t * strings);

/** \brief
 *  The platform advises Rust that the status of publishing our service has
 *  changed.
 */
void mdns_advertising_state_changed (
    TransportHandle_MdnsServerPlatformEvent_t const * handle,
    OnlineState_t state,
    TransportCondition_t condition);

/** \brief
 *  The SDK requests to drop its handle to the mDNS discovery transport
 * 
 *  At some point dropping this events channel will effectively shut down and
 *  remove the Transport. At time of writing, the Transport is still owned
 *  within Peer.
 */
void mdns_client_free_handle (
    TransportHandle_MdnsClientPlatformEvent_t * handle);

/** \brief
 *  The platform advises Rust that a peer has been identified.
 */
void mdns_platform_peer_appeared (
    TransportHandle_MdnsClientPlatformEvent_t const * handle,
    char const * announce_string);

/** \brief
 *  The platform advises Rust that a peer's service has disappeared from mDNS.
 */
void mdns_platform_peer_disappeared (
    TransportHandle_MdnsClientPlatformEvent_t const * handle,
    char const * announce_string);

/** \brief
 *  The platform advises Rust that the status of searching for services has
 *  changed.
 */
void mdns_scanning_state_changed (
    TransportHandle_MdnsClientPlatformEvent_t const * handle,
    OnlineState_t state,
    TransportCondition_t condition);

/** \brief
 *  The SDK requests to drop its handle to the mDNS advertising service.
 * 
 *  Ideally this should remove the advertiser automatically.
 *  At time of writing now this must be done manually through Peer.
 */
void mdns_server_free_handle (
    TransportHandle_MdnsServerPlatformEvent_t * handle);

/** \brief
 *  The platform advises Rust that we failed to resolve a peer's hostname and
 *  port
 */
void mdns_service_did_not_resolve (
    TransportHandle_MdnsClientPlatformEvent_t const * handle,
    char const * announce_string);

/** \brief
 *  The platform advises Rust that we have resolved a peer's hostname and port
 */
void mdns_service_did_resolve (
    TransportHandle_MdnsClientPlatformEvent_t const * handle,
    char const * announce_string,
    char const * hostname,
    uint16_t port);

Vec_char_ptr_t * new_c_string_vec (void);

/** \brief
 *  The SDK requests to drop its handle to this TCP Client transport
 */
void static_tcp_client_free_handle (
    TransportHandle_StaticTcpClientPlatformEvent_t * handle);

/** \brief
 *  Make an UninitializedDitto object as an opaque pointer.
 * 
 *  This object serves as an intermediate object that allows database access.
 *  This allows the SDK to check if a pre-existing site ID has been persisted.
 */
UninitializedDitto_t * uninitialized_ditto_make (
    char const * working_dir);

typedef enum LicenseVerificationResult {
    /** . */
    LICENSE_VERIFICATION_RESULT_LICENSE_OK = 0,
    /** . */
    LICENSE_VERIFICATION_RESULT_VERIFICATION_FAILED = -1,
    /** . */
    LICENSE_VERIFICATION_RESULT_LICENSE_EXPIRED = -2,
    /** . */
    LICENSE_VERIFICATION_RESULT_UNSUPPORTED_FUTURE_VERSION = -3,
} LicenseVerificationResult_t;

/** \brief
 *  Verify a base64 encoded license string
 * 
 *  # Parameters
 *  - `license`: A base64 encoded license string. This should be the output of
 *    `ditto_licenser::license_mgr::generate()`.
 *  - `out_error_msg`: An optional error message out parameter which will be
 *    written to if the license verification. This error message is simplified
 *    and appropriate to show directly to an SDK user.
 */
LicenseVerificationResult_t verify_license (
    char const * license,
    char * * out_err_msg);

/** \brief
 *  The SDK requests to drop its handle to this WebSocket Client transport
 */
void websocket_client_free_handle (
    TransportHandle_WebsocketClientPlatformEvent_t * handle);


#ifdef __cplusplus
} /* extern \"C\" */
#endif

#endif /* __RUST_DITTOFFI__ */
